"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const express_2 = __importDefault(require("express"));
const body_parser_1 = __importDefault(require("body-parser"));
const ts_http_errors_1 = require("ts-http-errors");
const nodejs_lite_logger_1 = require("nodejs-lite-logger");
const injector_1 = __importDefault(require("./injector"));
const helpers_1 = require("./helpers");
class Application {
    constructor(cb) {
        this.httpDisabled = false;
        this.enableAthorization = false;
        this.pendingInjections = new Map();
        this.autoInjections = [];
        this.plugins = [];
        this.express = express_1.default();
        this.router = express_2.default();
        this._injector = injector_1.default.getInstance();
        this._controllers = this._injector.controllers;
        this._injector.setInstance(this);
        cb ? cb(this.express) : void 0;
        this.use = function () {
            this.express.use(...arguments);
            return this;
        };
        this.use('/health', this.health.bind(this));
        this.use(body_parser_1.default.json());
        this.use(body_parser_1.default.urlencoded({ extended: false }));
        this.configProvider = new helpers_1.ConfigProvider({});
        return Application._instance || (Application._instance = this);
    }
    get Injector() {
        return this._injector;
    }
    get controllers() {
        return this._controllers;
    }
    registerModule(...args) {
        return this;
    }
    authMiddleware(req, res, next) {
        return __awaiter(this, arguments, void 0, function* () {
            try {
                if (this.enableAthorization) {
                    const token = req.headers[this.authorizationOptions.authorizationHeader.toLowerCase()] ||
                        req.query[this.authorizationOptions.authorizationQueryParam] ||
                        req.body[this.authorizationOptions.authorizationBodyField];
                    const authTarget = new helpers_1.AuthTarget(req, this.controllers);
                    if (!token)
                        throw new ts_http_errors_1.UnauthorizedError('Unauthorized');
                    req.auth = yield this.authorizationProvider.instance.verify(token, authTarget);
                }
                next();
            }
            catch (e) {
                this.handleError(e, ...arguments);
            }
        });
    }
    useAuthorizationProvider(provider, cb) {
        this.enableAthorization = true;
        this._injector.set(provider);
        this.authorizationProvider = {
            name: provider.name
        };
        this.authorizationOptions = new helpers_1.AuthOptions();
        cb ? cb(this.authorizationOptions) : void 0;
        return this;
    }
    useConfig(cb) {
        this.pendingInjections.set('ConfigProvider', cb ? cb(this.configProvider) : Promise.resolve());
        return this;
    }
    health() {
        this.configProvider.logLevels.includes('info') && nodejs_lite_logger_1.info('GET', '\t', '/health');
        arguments[1].status(200)
            .json({ status: 'live' });
    }
    handleNotFound() {
        this.handleError(new ts_http_errors_1.NotFoundError(`Route ${arguments[0].originalUrl} was not found`), ...arguments);
    }
    handleError(err, req, res, next) {
        const { configProvider } = Application._instance;
        if (err.statusCode) {
            configProvider.logLevels.includes('warning')
                && nodejs_lite_logger_1.warning(err.name, '\t', configProvider.printStack ? err : err.message);
            res.status(err.statusCode || 500).json(err);
        }
        else {
            configProvider.logLevels.includes('error') && nodejs_lite_logger_1.error(err);
            res.status(500).json(new ts_http_errors_1.InternalServerError(err.message));
        }
    }
    buildController(definition, name) {
        const { configProvider } = Application._instance;
        definition.instance = Application._instance.Injector.resolve(name);
        const router = express_2.default();
        const { routes, basePath, auth, instance } = definition;
        new Map([...routes.entries()]
            .sort(([path]) => path.startsWith('/:') ? 1 : -1))
            .forEach((routes, path) => Object.keys(routes).forEach((method) => {
            function handler(req, res) {
                return __awaiter(this, arguments, void 0, function* () {
                    let finished = false;
                    res.on('finish', () => finished = true);
                    const stub = () => { };
                    const before = routes[method]['before'] && routes[method]['before'].handler || stub;
                    const origin = routes[method]['origin'] && routes[method]['origin'].handler || stub;
                    const after = routes[method]['after'] && routes[method]['after'].handler;
                    try {
                        yield before.apply(instance, arguments);
                        res.result = (yield origin.call(instance, new helpers_1.RequestArguments(req))) || {};
                        (yield after) && after.apply(instance, arguments);
                    }
                    catch (e) {
                        Application._instance.handleError(e, ...arguments);
                    }
                    finally {
                        process.nextTick(() => finished ? void 0 : !after && res.send(res.result));
                    }
                });
            }
            routes[method].auth = routes[method].auth === false ? false : auth;
            const authMiddleware = routes[method].auth && this.authMiddleware.bind(this);
            const logMiddleware = configProvider.logLevels.includes('info')
                && function () {
                    nodejs_lite_logger_1.info(method.toUpperCase(), '\t', `${basePath}${path}`, '\t', 'target: ', '\t', routes[method]['before'] && routes[method]['before'].name || '', routes[method]['origin'] && routes[method]['origin'].name || '', routes[method]['after'] && routes[method]['after'].name || '');
                    arguments[2].call();
                };
            this.use(basePath, router[method](path, [logMiddleware, authMiddleware].filter(m => m), handler));
            configProvider.logLevels.includes('success')
                && nodejs_lite_logger_1.success(method.toUpperCase(), '\t', `${basePath}${path}`);
        }));
    }
    autoResolve(target) {
        this.autoInjections.push(target.name);
        this._injector.set(target);
        return this;
    }
    usePlugin(plugin) {
        this.plugins.push(plugin.name);
        this._injector.set(plugin);
        return this;
    }
    inject() {
        arguments.length == 1 && this._injector.setInstance(arguments[0]);
        arguments.length == 2 && this.pendingInjections.set(arguments[0], arguments[1] ? arguments[1](this.configProvider) : Promise.resolve());
        return this;
    }
    disableHttp() {
        this.httpDisabled = true;
        return this;
    }
    start(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.pendingInjections.get('ConfigProvider');
            this._injector.setInstance(this.configProvider);
            yield Promise.all([...this.pendingInjections.entries()]
                .filter(([key]) => key !== 'ConfigProvider')
                .map(([key, injectionPromise]) => __awaiter(this, void 0, void 0, function* () {
                const injection = yield injectionPromise;
                return this._injector.setInstance(key, injection);
            })));
            this.autoInjections.forEach((inj) => this._injector.resolve(inj));
            this.plugins.forEach((inj) => {
                this._injector.resolve(inj);
                if (!this._injector.getPlugin(inj)) {
                    this._injector.plugins.set(inj, {});
                }
            });
            if (this.authorizationProvider) {
                this.authorizationProvider.instance = this._injector.resolve(this.authorizationProvider.name);
            }
            if (!this.httpDisabled) {
                this.controllers.forEach(this.buildController.bind(this));
            }
            this.use(this.handleNotFound.bind(this));
            this.use(this.handleError.bind(this));
            cb(this.express, this.configProvider);
        });
    }
}
exports.default = Application;
