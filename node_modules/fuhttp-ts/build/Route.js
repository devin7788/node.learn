/**
 * fuhttp-ts 1.2.1 <https://github.com/fosenutvikling/fuHTTP-ts#readme>
 * Route.js
 *
 * a HTTP-server written in TypeScript using Node.js
 *
 * Copyright (c) 2018 Jonas Kirkemyr, Fosen-Utvikling AS (http://fosen-utvikling.no), contributors
 * Licensed under the MIT license.
 */
 "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const qs = require("qs");
var HTTP_METHODS;
(function (HTTP_METHODS) {
    HTTP_METHODS["GET"] = "GET";
    HTTP_METHODS["POST"] = "POST";
    HTTP_METHODS["PUT"] = "PUT";
    HTTP_METHODS["DELETE"] = "DELETE";
})(HTTP_METHODS = exports.HTTP_METHODS || (exports.HTTP_METHODS = {}));
class NoMatchingHttpMethodException extends Error {
    constructor(msg, supportedMethods) {
        super(msg);
        this.supportedMethods = supportedMethods;
    }
}
exports.NoMatchingHttpMethodException = NoMatchingHttpMethodException;
/**
 * The Route class for parsing and matching incoming http-requests
 * based on an URL
 */
class Route {
    /**
     * Creates an instance of Route.
     */
    constructor() {
        this._middlewares = [];
        this._nextRoutes = {};
    }
    static getHttpPublicMethodForRoute(route, httpMethod) {
        switch (httpMethod) {
            case HTTP_METHODS.GET:
                return route.get;
            case HTTP_METHODS.POST:
                return route.post;
            case HTTP_METHODS.PUT:
                return route.put;
            case HTTP_METHODS.DELETE:
                return route.delete;
            default:
                throw new Error('Unsupported HTTP Method');
        }
    }
    static appendQueryParams(url, params) {
        const queryPosition = url.indexOf('?');
        if (queryPosition >= 0) {
            const queryStr = url.substr(queryPosition + 1);
            const parsedQuery = qs.parse(queryStr);
            params.push(parsedQuery);
            return url.substr(0, queryPosition);
        }
        return url;
    }
    /**
     * Remove last trailing slash
     * For route matching: 'users' and 'users/' should be mapped to the same route
     * @param str input string to remove trailing slash from
     */
    static removeTrailingSlash(str) {
        if (str && str[str.length - 1] === '/')
            return str.substring(0, str.length - 1);
        return str;
    }
    static removeSlashFromFront(str) {
        if (str[0] === '/')
            return str.substr(1);
        return str;
    }
    static fixRequestUrlForAdding(str) {
        str = Route.removeTrailingSlash(str);
        str = Route.removeSlashFromFront(str);
        return str;
    }
    addRoute(HttpMethod, requestUrl, func) {
        requestUrl = Route.fixRequestUrlForAdding(requestUrl);
        const splittedRoute = requestUrl.split('/');
        if (splittedRoute[0] !== '') {
            const key = splittedRoute[0];
            const rest = splittedRoute.splice(1).join('/');
            if (this._nextRoutes[key]) {
                Route.getHttpPublicMethodForRoute(this._nextRoutes[key], HttpMethod).apply(this._nextRoutes[key], [rest, func]);
            }
            else if (key[0] === Route.paramIdentifier) {
                const tempRoute = this._nextRoutes[Route.paramRoute] || new Route();
                Route.getHttpPublicMethodForRoute(tempRoute, HttpMethod).apply(tempRoute, [
                    rest,
                    func
                ]);
                this._nextRoutes[Route.paramRoute] = tempRoute;
            }
            else {
                const tempRoute = new Route();
                Route.getHttpPublicMethodForRoute(tempRoute, HttpMethod).apply(tempRoute, [
                    rest,
                    func
                ]);
                this._nextRoutes[key] = tempRoute;
            }
        }
        else {
            this.assignFnToHttpMethod(HttpMethod, func);
        }
    }
    assignFnToHttpMethod(httpMethod, fn) {
        switch (httpMethod) {
            case HTTP_METHODS.GET:
                this._getFn = fn;
                break;
            case HTTP_METHODS.POST:
                this._postFn = fn;
                break;
            case HTTP_METHODS.PUT:
                this._putFn = fn;
                break;
            case HTTP_METHODS.DELETE:
                this._deleteFn = fn;
                break;
            default:
                throw new Error('Unsupported HTTP Method');
        }
    }
    getFnForHttpMethod(httpMethod) {
        switch (httpMethod) {
            case HTTP_METHODS.GET:
                return this._getFn;
            case HTTP_METHODS.POST:
                return this._postFn;
            case HTTP_METHODS.PUT:
                return this._putFn;
            case HTTP_METHODS.DELETE:
                return this._deleteFn;
            default:
                throw new Error('Unsupported HTTP Method');
        }
    }
    runMiddlewares(middlewares, req, res) {
        for (let i = 0; i < middlewares.length; ++i)
            if (!middlewares[i].alter(req, res))
                return false;
        return true;
    }
    /**
     * Method for adding a new route for GET-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    get(requestUrl, func) {
        this.addRoute(HTTP_METHODS.GET, requestUrl, func);
    }
    /**
     * Method for adding a new route for POST-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    post(requestUrl, func) {
        this.addRoute(HTTP_METHODS.POST, requestUrl, func);
    }
    /**
     * Method for adding a new route for PUT-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    put(requestUrl, func) {
        this.addRoute(HTTP_METHODS.PUT, requestUrl, func);
    }
    /**
     * Method for adding a new route for DELETE-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    delete(requestUrl, func) {
        this.addRoute(HTTP_METHODS.DELETE, requestUrl, func);
    }
    /**
     * Match a route to current `row` of routes based on url in {inputParams}
     * Returns a boolean value whether a route is found or not.
     * If the route is found, but it doesn't match with the HTTP.method in {req},
     * and error is thrown
     *
     * @param inputParams url  to match, params to parse, and middlewares to run on route match
     * @param req Http Request
     * @param res Http Response
     */
    parse(inputParams, req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            // Should stop processing of data if a middleware fails, to prevent setting headers if already changed by a middleware throwing an error
            const routeUrl = Route.fixRequestUrlForAdding(inputParams.url);
            const splittedUrls = routeUrl.split('/');
            inputParams.middlewares = [];
            const middlewares = this._middlewares.concat(inputParams.middlewares || []);
            let params = inputParams.params || [];
            if (splittedUrls.length === 1)
                splittedUrls[0] = Route.appendQueryParams(splittedUrls[0], params);
            if (splittedUrls[0] !== '') {
                let key = splittedUrls[0];
                const nextUrl = splittedUrls.splice(1).join('/');
                let nextRoute;
                if (this._nextRoutes[key]) {
                    nextRoute = this._nextRoutes[key];
                }
                else if (this._nextRoutes[Route.paramRoute]) {
                    params.push(key);
                    nextRoute = this._nextRoutes[Route.paramRoute];
                }
                else
                    return false;
                return yield nextRoute.parse({
                    url: nextUrl,
                    params,
                    middlewares
                }, req, res);
            }
            if (!this.runMiddlewares(middlewares, req, res))
                return false;
            let callback = this.getFnForHttpMethod(req.method);
            // If callback function is not set, the current HTTP-method is not supported for the current route
            if (!callback) {
                // Set of supported HTTP-methods for current route
                const obj = {};
                if (this._getFn)
                    obj.get = true;
                if (this._postFn)
                    obj.post = true;
                if (this._putFn)
                    obj.put = true;
                if (this._deleteFn)
                    obj.delete = true;
                throw new NoMatchingHttpMethodException(`${req.method} not supported for route`, obj);
            }
            try {
                yield callback.apply(null, [req, res, ...params]);
            }
            catch (ex) {
                throw ex;
            }
            return true;
        });
    }
    /**
     * Appends a middleware to the route
     */
    use(middleware) {
        this._middlewares.push(middleware);
    }
    /**
     * Appends an existing route to {this} routes
     * If the route doesn't contain a {routeName}, it is up to the developer to make sure no routes will overlap, as it will result in the last added route to
     * never match!
     */
    add(path, route) {
        if (path[0] === '/')
            path = path.substr(1);
        const splittedRoute = path.split('/');
        const key = splittedRoute[0].trim();
        if (splittedRoute.length > 1) {
            const rest = splittedRoute.slice(1).join('/');
            if (rest) {
                // If rest is not an empty string, add route to existing or new route
                let nextRoute;
                if (this._nextRoutes[key]) {
                    nextRoute = this._nextRoutes[key];
                }
                else {
                    nextRoute = new Route();
                    this._nextRoutes[key] = nextRoute;
                }
                return nextRoute.add(rest, route);
            }
        }
        if (this._nextRoutes[key]) {
            Object.keys(route._nextRoutes).forEach(routeKey => {
                this._nextRoutes[key].add(routeKey, route._nextRoutes[routeKey]);
            });
        }
        else {
            this._nextRoutes[key] = route;
        }
    }
    /**
     * Retrieves all registered middlewares
     */
    get middleware() {
        return this._middlewares;
    }
    get getFunction() {
        return this._getFn;
    }
    get postFunction() {
        return this._postFn;
    }
    get putFunction() {
        return this._putFn;
    }
    get deleteFunction() {
        return this._deleteFn;
    }
    get nextRoute() {
        return this._nextRoutes;
    }
}
/** Strings starting with identifier should be parsed as a parameter */
Route.paramIdentifier = ':';
/** Parameter route. If a parameter is defined, add a new {paramRoute} in {nextRoute} */
Route.paramRoute = '_pa%ram';
exports.Route = Route;
//# sourceMappingURL=Route.js.map