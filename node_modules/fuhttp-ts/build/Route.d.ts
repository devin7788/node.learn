/// <reference types="node" />
import * as http from 'http';
import { IBodyRequest } from './Server';
import { IMiddleware } from './middlewares/IMiddleware';
import { IServerResponse } from './middlewares/JsonResponse';
export declare enum HTTP_METHODS {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    DELETE = "DELETE"
}
export declare type RequestFunction = (req: http.IncomingMessage, res: http.ServerResponse, ...params: any[]) => void;
export interface IParseParams {
    url: string;
    middlewares?: IMiddleware[];
    params?: string[];
}
export declare class NoMatchingHttpMethodException extends Error {
    supportedMethods: {
        [key: string]: boolean;
    };
    constructor(msg: string, supportedMethods: {
        [key: string]: boolean;
    });
}
/**
 * The Route class for parsing and matching incoming http-requests
 * based on an URL
 */
export declare class Route {
    /** Strings starting with identifier should be parsed as a parameter */
    static readonly paramIdentifier: string;
    /** Parameter route. If a parameter is defined, add a new {paramRoute} in {nextRoute} */
    static readonly paramRoute: string;
    private static getHttpPublicMethodForRoute;
    private static appendQueryParams;
    /**
     * Remove last trailing slash
     * For route matching: 'users' and 'users/' should be mapped to the same route
     * @param str input string to remove trailing slash from
     */
    static removeTrailingSlash(str: string): string;
    static removeSlashFromFront(str: string): string;
    static fixRequestUrlForAdding(str: string): string;
    /**
     * Route for responding to get-request
     */
    private _getFn;
    /**
     * Store all routes for responding to a post-request
     */
    private _postFn;
    /**
     * Store all routes for responding to a delete-request
     */
    private _deleteFn;
    /**
     * Store route for responding to a put-request
     */
    private _putFn;
    private _nextRoutes;
    /**
     * Middlewares to be run before a route match
     */
    private _middlewares;
    /**
     * Creates an instance of Route.
     */
    constructor();
    private addRoute;
    private assignFnToHttpMethod;
    private getFnForHttpMethod;
    private runMiddlewares;
    /**
     * Method for adding a new route for GET-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    get(requestUrl: string, func: (req: http.ServerRequest, res: IServerResponse, ...params: any[]) => void): void;
    /**
     * Method for adding a new route for POST-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    post(requestUrl: string, func: (req: IBodyRequest, res: IServerResponse, ...params: any[]) => void): void;
    /**
     * Method for adding a new route for PUT-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    put(requestUrl: string, func: (req: IBodyRequest, res: IServerResponse, ...params: any[]) => void): void;
    /**
     * Method for adding a new route for DELETE-requests
     *
     * @param requestUrl url-endpoint to match incoming requests
     * @param func to call when match is found
     */
    delete(requestUrl: string, func: (req: IBodyRequest, res: IServerResponse, ...params: any[]) => void): void;
    /**
     * Match a route to current `row` of routes based on url in {inputParams}
     * Returns a boolean value whether a route is found or not.
     * If the route is found, but it doesn't match with the HTTP.method in {req},
     * and error is thrown
     *
     * @param inputParams url  to match, params to parse, and middlewares to run on route match
     * @param req Http Request
     * @param res Http Response
     */
    parse(inputParams: IParseParams, req: http.IncomingMessage, res: http.ServerResponse): Promise<boolean>;
    /**
     * Appends a middleware to the route
     */
    use(middleware: IMiddleware): void;
    /**
     * Appends an existing route to {this} routes
     * If the route doesn't contain a {routeName}, it is up to the developer to make sure no routes will overlap, as it will result in the last added route to
     * never match!
     */
    add(path: string, route: Route): void;
    /**
     * Retrieves all registered middlewares
     */
    readonly middleware: IMiddleware[];
    readonly getFunction: RequestFunction;
    readonly postFunction: RequestFunction;
    readonly putFunction: RequestFunction;
    readonly deleteFunction: RequestFunction;
    readonly nextRoute: {
        [key: string]: Route;
    };
}
