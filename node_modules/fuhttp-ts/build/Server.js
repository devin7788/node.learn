/**
 * fuhttp-ts 1.2.1 <https://github.com/fosenutvikling/fuHTTP-ts#readme>
 * Server.js
 *
 * a HTTP-server written in TypeScript using Node.js
 *
 * Copyright (c) 2018 Jonas Kirkemyr, Fosen-Utvikling AS (http://fosen-utvikling.no), contributors
 * Licensed under the MIT license.
 */
 "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Route_1 = require("./Route");
const http = require("http");
const formidable = require("formidable");
const JsonResponse_1 = require("./middlewares/JsonResponse");
const BodyJsonParse_1 = require("./middlewares/BodyJsonParse");
const DefaultResponse_1 = require("./DefaultResponse");
// Keys stored in `_errorFunctions` of the Server class
const ERROR_KEY_REQUEST = 'request';
const ERROR_KEY_RESPONSE = 'response';
const ERROR_KEY_NOTFOUND = 'notfound';
const ERROR_KEY_OVERFLOW = 'overflow';
const ERROR_EXCEPTION = 'exception';
const ERROR_METHOD_NOT_ALLOWED = 'notallowed';
class OverflowError extends Error {
}
class FormidableError extends Error {
}
/**
 * The HTTP-server class for receiving and responding to HTTP-requests
 */
class Server {
    /**
     * Creates an instance of Server.
     */
    constructor(port, host = null) {
        this.onServerRequest = (request, response) => __awaiter(this, void 0, void 0, function* () {
            request.on('error', this.onRequestServerError(response));
            response.on('error', this.onResponseServerError(response));
            // Should try to parse body data
            if (request.method !== 'GET' && request.headers['content-length'] != undefined) {
                try {
                    request = yield this.getRequestWithBody(request);
                }
                catch (ex) {
                    if (ex instanceof OverflowError) {
                        this._errorFunctions[ERROR_KEY_OVERFLOW](response);
                    }
                    else if (ex instanceof FormidableError) {
                        request.emit('error', 'Error parsing body');
                    }
                    else {
                        request.emit('error', `Unknown error occured: ${ex}`);
                    }
                    return;
                }
            }
            this.routeLookup(request, response);
        });
        this.onRequestServerError = (response) => {
            return (error) => this._errorFunctions[ERROR_KEY_REQUEST](error, response);
        };
        this.onResponseServerError = (response) => {
            return (error) => this._errorFunctions[ERROR_KEY_RESPONSE](error, response);
        };
        this.getRequestWithBody = (request) => __awaiter(this, void 0, void 0, function* () {
            const contentType = this.parseRequestContentType(request);
            request.contentType = contentType;
            if (contentType === 'multipart/form-data') {
                const { fields, files } = yield this.parseFormData(request);
                request.fields = fields;
                request.files = files;
                return request;
            }
            else {
                const body = yield this.parseRequestBody(request);
                request.body = body;
                return request;
            }
        });
        this.parseRequestContentType = (request) => {
            const contentTypeRaw = request.headers['content-type'];
            const contentType = contentTypeRaw
                ? contentTypeRaw.slice(0, contentTypeRaw.indexOf(';'))
                : null;
            return contentType;
        };
        this.parseFormData = (request) => {
            const form = new formidable.IncomingForm();
            return new Promise((resolve, reject) => {
                form.parse(request, (error, fields, files) => {
                    if (error)
                        return reject(new FormidableError(error));
                    return resolve({ fields, files });
                });
            });
        };
        this.parseRequestBody = (request) => {
            let body = '';
            return new Promise((resolve, reject) => {
                request.on('data', data => {
                    body += data;
                    if (body.length > 1e6) {
                        return reject(new OverflowError());
                    }
                });
                request.on('end', () => {
                    return resolve(body);
                });
            });
        };
        // Initialize variables to be populated
        this.port = port;
        this.hostname = host;
        this.route = null;
        this._middlewares = Server.defaultMiddleWares();
        this._errorFunctions = {};
        this.connected = false;
        this.server = http.createServer();
        this.server.on('request', this.onServerRequest);
    }
    static defaultMiddleWares() {
        return [new JsonResponse_1.JsonResponse(), new BodyJsonParse_1.BodyJsonParse()];
    }
    /**
     * Look up route based on request url.
     * Will load any middlewares if defined.
     * If no routes are found, the `ERROR_KEY_NOTFOUND` error functions will be called
     *
     * @param request
     * @param response
     */
    routeLookup(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            // Load middlewares
            var length = this.middlewares.length;
            for (let i = 0; i < length; ++i)
                if (!this.middlewares[i].alter(request, response))
                    // Should stop processing of data if a middleware fails, to prevent setting headers if already changed by a middleware throwing an error
                    return false;
            try {
                if (yield this.route.parse({ url: request.url }, request, response))
                    return true;
                // 404 error
                this._errorFunctions[ERROR_KEY_NOTFOUND](response);
                return false;
            }
            catch (ex) {
                if (ex instanceof Route_1.NoMatchingHttpMethodException) {
                    this._errorFunctions[ERROR_METHOD_NOT_ALLOWED](Object.keys(ex.supportedMethods), response);
                }
                else {
                    this._errorFunctions[ERROR_EXCEPTION](ex, response);
                }
            }
            return false;
        });
    }
    setDefaultErrorResponses() {
        if (this._errorFunctions[ERROR_KEY_REQUEST] == undefined)
            this._errorFunctions[ERROR_KEY_REQUEST] = DefaultResponse_1.DefaultErrorResponse;
        if (this._errorFunctions[ERROR_KEY_RESPONSE] == undefined)
            this._errorFunctions[ERROR_KEY_RESPONSE] = DefaultResponse_1.DefaultNoResponseErrorResponse;
        if (this._errorFunctions[ERROR_KEY_NOTFOUND] == undefined)
            this._errorFunctions[ERROR_KEY_NOTFOUND] = DefaultResponse_1.DefaultNotFoundErrorResponse;
        if (this._errorFunctions[ERROR_KEY_OVERFLOW] == undefined)
            this._errorFunctions[ERROR_KEY_OVERFLOW] = DefaultResponse_1.DefaultLargeEntityErrorResponse;
        if (this._errorFunctions[ERROR_METHOD_NOT_ALLOWED] == undefined)
            this._errorFunctions[ERROR_METHOD_NOT_ALLOWED] = DefaultResponse_1.DefaultMethodNotAllowedResponse;
    }
    printServerInfo() {
        const { address, port } = this.server.address();
        console.log(`STARTED SERVER: http://${address === '::' || address === '127.0.0.1' ? 'localhost' : address}:${port} 🏁`);
    }
    /**
     * Whether the server is listening for connections or not. Will
     * only be true as long as the `listen` method is called
     */
    get isListening() {
        return this.connected;
    }
    /**
     * Set functions to run on triggered events
     *
     * @param event to listen for
     * @param func function to run on event triggered
     * @returns Whether event added successfully for listening
     * @throws Error if the provided event argument cannot be added as eventListener
     */
    on(event, func) {
        switch (event) {
            case 'clientError':
            case 'close':
            case 'upgrade':
                break;
            case ERROR_KEY_RESPONSE:
                this._errorFunctions[ERROR_KEY_RESPONSE] = func;
                return true;
            case ERROR_KEY_REQUEST:
                this._errorFunctions[ERROR_KEY_REQUEST] = func;
                return true;
            case ERROR_KEY_NOTFOUND:
                this._errorFunctions[ERROR_KEY_NOTFOUND] = func;
                return true;
            case ERROR_EXCEPTION:
                this._errorFunctions[ERROR_EXCEPTION] = func;
                return true;
            case ERROR_METHOD_NOT_ALLOWED:
                this._errorFunctions[ERROR_METHOD_NOT_ALLOWED] = func;
                return true;
            default:
                throw new Error('Event: ' + event + ' not recognized');
        }
        this.server.on(event, func);
    }
    /**
     * Function to run on a "clientError"
     * https://nodejs.org/api/http.html#http_event_clienterror
     */
    set onClientError(func) {
        this.server.on('clientError', func);
    }
    /**
     * Function to run when the server closes for new connections
     * https://nodejs.org/api/http.html#http_event_close
     */
    set onClose(func) {
        this.server.on('close', func);
    }
    /**
     * Function to run when "upgrade" emitted by client
     * https://nodejs.org/api/http.html#http_event_upgrade_1
     */
    set onUpgrade(func) {
        this.server.on('upgrade', func);
    }
    /**
     * Function to run if a request throws an error
     */
    set onRequestError(func) {
        if (this._errorFunctions[ERROR_KEY_REQUEST] != undefined)
            throw new Error('Request error function already set');
        this._errorFunctions[ERROR_KEY_REQUEST] = func;
    }
    /**
     * Function to run if a response throws an error
     */
    set onResponseError(func) {
        if (this._errorFunctions[ERROR_KEY_RESPONSE] != undefined)
            throw new Error('Response error function already set');
        this._errorFunctions[ERROR_KEY_RESPONSE] = func;
    }
    /**
     * Function to run if a route is not found (404 http method)
     */
    set onNotFoundError(func) {
        if (this._errorFunctions[ERROR_KEY_NOTFOUND] != undefined)
            throw new Error('Not-Found error function already set');
        this._errorFunctions[ERROR_KEY_NOTFOUND] = func;
    }
    /**
     * Function to run if a request provides too much data
     */
    set onOverflowError(func) {
        if (this._errorFunctions[ERROR_KEY_OVERFLOW] != undefined)
            throw new Error('Overflow error function already set');
        this._errorFunctions[ERROR_KEY_OVERFLOW] = func;
    }
    set onException(func) {
        if (this._errorFunctions[ERROR_EXCEPTION] != undefined)
            throw new Error('Exception error function already set');
        this._errorFunctions[ERROR_EXCEPTION] = func;
    }
    set onMethodNotAllowed(func) {
        if (this._errorFunctions[ERROR_METHOD_NOT_ALLOWED] != undefined)
            throw new Error('Method Not Found error function already set');
        this._errorFunctions[ERROR_METHOD_NOT_ALLOWED] = func;
    }
    /**
     * Adds a new route for the http-server for accepting http-requests
     *
     * @param routeName
     * @param route object to add
     */
    add(routeName, route) {
        // Check if root route should be replaced
        if (routeName === '/') {
            if (this.route) {
                throw new Error('Root route about to be overwritten. You need to update your route structure!');
            }
            this.route = route;
        }
        else {
            // Need to define root route, if not already defined
            if (!this.route)
                this.route = new Route_1.Route();
            this.route.add(routeName, route);
        }
    }
    /**
     * Appends a middleware
     *
     * @param middleware to be added
     */
    use(middleware) {
        this._middlewares.push(middleware);
    }
    /**
     * Retrieve all registered middlewares
     */
    get middlewares() {
        return this._middlewares;
    }
    /**
     * Retrieve the function to call when a route is not found
     * Used by "Route"
     */
    get notfound() {
        return this._errorFunctions[ERROR_KEY_NOTFOUND];
    }
    close() {
        this.server.close();
    }
    /**
     * Start the http-server, for accepting incomming connections on the
     * given port and hostname
     * @throws Error If no Routes are added before starting HTTP-server
     */
    listen() {
        if (this.route == null)
            throw new Error('No routes added, and no connections will therefore be accepted.');
        this.setDefaultErrorResponses();
        this.server.listen(this.port, this.hostname);
        this.printServerInfo();
        this.connected = true;
    }
}
exports.Server = Server;
//# sourceMappingURL=Server.js.map